package socket

import (
	"encoding/json"
	"log"
	"sync"

	"github.com/TryHanger/digital_signage/internal/cache"
	"github.com/TryHanger/digital_signage/internal/model"
	"github.com/TryHanger/digital_signage/internal/repository"
	"github.com/gorilla/websocket"
)

type WebSocketNotifier struct {
	mu            sync.RWMutex
	connections   map[uint]*websocket.Conn
	monitorRepo   *repository.MonitorRepository
	scheduleCache *cache.ScheduleCache
	onConnect     func(monitorID uint)
}

func NewWebSocketNotifier(monitorRepo *repository.MonitorRepository, cache *cache.ScheduleCache) *WebSocketNotifier {
	return &WebSocketNotifier{
		connections:   make(map[uint]*websocket.Conn),
		monitorRepo:   monitorRepo,
		scheduleCache: cache,
	}
}

func (n *WebSocketNotifier) HandleConnection(conn *websocket.Conn) {
	defer conn.Close()

	for {
		_, msg, err := conn.ReadMessage()
		if err != nil {
			log.Printf("‚ö†Ô∏è –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: %v", err)
			return
		}

		var payload map[string]interface{}
		if err := json.Unmarshal(msg, &payload); err != nil {
			log.Printf("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: %v", err)
			continue
		}

		event, ok := payload["event"].(string)
		if !ok {
			log.Println("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å–æ–±—ã—Ç–∏—è")
			continue
		}

		data, ok := payload["data"].(map[string]interface{})
		if !ok {
			log.Println("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
			continue
		}

		switch event {
		case "register_monitor":
			n.handleRegisterByToken(conn, data)

		default:
			log.Printf("üì© –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ: %s", event)
		}
	}
}

func (n *WebSocketNotifier) handleRegisterByToken(conn *websocket.Conn, data map[string]interface{}) {
	token, ok := data["token"].(string)
	if !ok || token == "" {
		log.Println("‚ùå –¢–æ–∫–µ–Ω –º–æ–Ω–∏—Ç–æ—Ä–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω")
		conn.WriteJSON(map[string]interface{}{
			"event": "error",
			"data":  "token_required",
		})
		conn.Close()
		return
	}

	monitor, err := n.monitorRepo.GetByToken(token)
	if err != nil {
		log.Printf("‚ùå –ú–æ–Ω–∏—Ç–æ—Ä —Å —Ç–æ–∫–µ–Ω–æ–º %s –Ω–µ –Ω–∞–π–¥–µ–Ω: %v", token, err)
		conn.WriteJSON(map[string]interface{}{
			"event": "error",
			"data":  "invalid_token",
		})
		conn.Close()
		return
	}

	// üîí –ó–∞—â–∏—Ç–∞ –æ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
	n.mu.Lock()
	if _, exists := n.connections[monitor.ID]; exists {
		n.mu.Unlock()
		log.Printf("‚ö†Ô∏è –ú–æ–Ω–∏—Ç–æ—Ä %s (ID: %d) —É–∂–µ –ø–æ–¥–∫–ª—é—á—ë–Ω, –∑–∞–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ", monitor.Name, monitor.ID)
		conn.WriteJSON(map[string]interface{}{
			"event": "error",
			"data":  "monitor_already_connected",
		})
		conn.Close()
		return
	}

	n.connections[monitor.ID] = conn
	n.mu.Unlock()

	log.Printf("üñ•Ô∏è –ú–æ–Ω–∏—Ç–æ—Ä –ø–æ–¥–∫–ª—é—á—ë–Ω: %s (ID: %d, Token: %s)", monitor.Name, monitor.ID, token)

	// üßπ –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –æ—á–∏—Å—Ç–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
	defer func() {
		n.mu.Lock()
		delete(n.connections, monitor.ID)
		n.mu.Unlock()
		log.Printf("üîå –ú–æ–Ω–∏—Ç–æ—Ä %s (ID: %d) –æ—Ç–∫–ª—é—á—ë–Ω", monitor.Name, monitor.ID)
	}()

	if n.onConnect != nil {
		n.onConnect(monitor.ID)
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –º–æ–Ω–∏—Ç–æ—Ä—É
	schedules := n.scheduleCache.GetByMonitorID(monitor.ID)
	conn.WriteJSON(map[string]interface{}{
		"event": "init_schedules",
		"data":  schedules,
	})

	// ‚è≥ –ß–∏—Ç–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è (—á—Ç–æ–±—ã defer —Å—Ä–∞–±–æ—Ç–∞–ª)
	for {
		_, _, err := conn.ReadMessage()
		if err != nil {
			log.Printf("‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –º–æ–Ω–∏—Ç–æ—Ä–æ–º %d –∑–∞–∫—Ä—ã—Ç–æ: %v", monitor.ID, err)
			break
		}
	}
}

func (n *WebSocketNotifier) NotifyScheduleUpdate(monitorID uint, schedule model.Schedule) {
	n.mu.RLock()
	conn, ok := n.connections[monitorID]
	n.mu.RUnlock()

	if !ok {
		log.Printf("‚ö†Ô∏è –ú–æ–Ω–∏—Ç–æ—Ä %d –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω", monitorID)
		return
	}

	msg := map[string]interface{}{
		"event": "schedule_update",
		"data":  schedule,
	}

	if err := conn.WriteJSON(msg); err != nil {
		log.Printf("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä—É %d: %v", monitorID, err)
	}

	log.Printf("üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –º–æ–Ω–∏—Ç–æ—Ä—É %d", monitorID)

}

func (n *WebSocketNotifier) OnConnect(handler func(monitorID uint)) {
	n.onConnect = handler
}
